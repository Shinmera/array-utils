<!DOCTYPE html> <html lang="EN"> <head> <meta charset="utf-8"> <title>Array Utils</title> <style>html body{margin:0 auto 0 auto;padding:20px;max-width:1024px;font-family:sans-serif;font-size:14pt;overflow-y:scroll;}html body a{text-decoration:none;}html body a[href]{color:#0055AA;}html body a[href]:hover{color:#0088EE;}html body pre{background:#FAFAFA;border:1px solid #DDDDDD;padding:0.75em;overflow-x:auto;}html body pre >code a[href]{color:#223388;}article.project h1{font-size:1.7em;}article.project h1,article.project h2,article.project h3,article.project h4,article.project h5,article.project h6{margin:0.2em 0 0.1em 0;text-indent:1em;}article.project >header{text-align:center;}article.project >header img.logo{display:block;margin:auto;max-height:170px;}article.project >header h1{display:inline-block;text-indent:0;font-size:2.5em;}article.project >header .version{vertical-align:bottom;}article.project >header .languages{margin-top:-0.5em;text-transform:capitalize;}article.project >header .description{margin:0;}article.project >header .pages{margin-top:0.5em;font-size:1.2em;text-transform:capitalize;}article.project >header .pages a{display:inline-block;padding:0 0.2em;}article.project >section{margin:1em 0 1em 0;}article.project #index >ul{list-style:none;margin:0;padding:0;}article.project .row label{display:inline-block;min-width:8em;}article.project #system .row{display:flex;}article.project #system #dependencies{display:inline;margin:0;padding:0;}article.project #system #dependencies li{display:inline;padding:0 0.2em;}article.project #system #author label{vertical-align:top;}article.project #system #author ul{display:inline-block;margin:0;padding:0;list-style:none;}article.definition{margin:1em 0 0 0;}article.definition >header h1,article.definition >header h2,article.definition >header h3,article.definition >header h4,article.definition >header h5,article.definition >header h6{text-indent:0;display:inline-block;}article.definition >header ul{display:inline-block;list-style:none;margin:0;padding:0;}article.definition >header ul li{display:inline-block;padding:0 0.2em 0 0;}article.definition >header .visibility{display:none;}article.definition >header .visibility,article.definition >header .type{text-transform:lowercase;}article.definition >header .source-link{visibility:hidden;float:right;}article.definition >header .source-link:after{visibility:visible;content:"[SRC]";}article.definition .docstring{margin:0 0 0 1em;}article.definition .docstring pre{font-size:0.8em;white-space:pre-wrap;}.definition.package >header ul.nicknames{display:inline-block;list-style:none;margin:0;padding:0 0 0 1em;}.definition.package >header ul.nicknames li{display:inline;}.definition.package >header ul.nicknames:before{content:"(";}.definition.package >header ul.nicknames:after{content:")";}.definition.package ul.definitions{margin:0;list-style:none;padding:0 0 0 0.5em;}.definition.callable >header .name:before,.definition.type >header .name:before{content:"(";font-weight:normal;}.definition.callable >header .arguments:after,.definition.type >header .arguments:after{content:")";}.definition.callable >header .arguments .arguments:before,.definition.type >header .arguments .arguments:before{content:"(";}.definition.callable >header .arguments .argument,.definition.type >header .arguments .argument{padding:0;}.definition.callable >header .arguments .argument.lambda-list-keyword,.definition.type >header .arguments .argument.lambda-list-keyword{color:#991155;}.definition li>mark{background:none;border-left:0.3em solid #0088EE;padding-left:0.3em;display:block;}</style> </head> <body> <article class="project"> <header>   <h1>array utils</h1>   <span class="version">1.3.0</span>    <p class="description">A few utilities for working with arrays.</p>   </header> <section id="documentation"><h2 id="about_array-utils">About Array-Utils</h2> <p>A miniature toolkit that contains some useful shifting/popping/pushing functions for arrays and vectors. This exists mostly because I've used these functions in multiple places already, so splitting it off into its own thing is a good idea. Originally from <a href="http://shinmera.github.io/plump/">Plump</a>.</p> </section>   <section id="system"> <h2>System Information</h2>  <div class="row"> <label for="version">Version:</label> <a id="version">1.3.0</a> </div>    <div class="row" id="author"> <label for="author">Author:</label> <a href="mailto:shinmera@tymoon.eu">Yukari Hafner</a> </div>   <div class="row"> <label for="license">License:</label> <a id="license" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/LICENSE">zlib</a> </div>   <div class="row"> <label for="homepage">Homepage:</label> <a id="homepage" href="https://Shinmera.github.io/array-utils/">https://Shinmera.github.io/array-utils/</a> </div>   <div class="row"> <label for="bug-tracker">Bug Tracker:</label> <a id="bug-tracker" href="https://shinmera.com/project/array-utils/issues">https://shinmera.com/project/array-utils/issues</a> </div>   <div class="row"> <label for="sources">Sources:</label> <a id="sources" href="https://shinmera.com/project/array-utils.git">https://shinmera.com/project/array-utils.git</a> </div>  </section>    <section id="index"> <h2>Definition Index</h2> <ul> <li> <article class="definition package" id="PACKAGE ARRAY-UTILS"> <header> <h3> <a href="#PACKAGE%20ARRAY-UTILS">ARRAY-UTILS</a> </h3> <ul class="nicknames"> <li>ORG.SHIRAKUMO.ARRAY-UTILS</li> </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> <ul class="definitions"> <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:ARRAY-SHIFT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3AARRAY-SHIFT">ARRAY-SHIFT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ARRAY</li>    <li class="argument lambda-list-keyword">&amp;KEY</li>    <li class="argument">N</li>    <li class="argument">FROM</li>    <li class="argument">TO</li>    <li class="argument">ADJUST</li>    <li class="argument">FILL</li>    <li class="argument">CONTENTS</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L34">Source</a>  </header> <div class="docstring"><pre>Shifts a subset of array elements in either direction for a specified amount.
Optionally also extends the array and fills empty space with a given element.

N        --- The amount to be moved. If positive, things are shifted to the right. If
             negative, things are shifted to the left.
FROM     --- The left point of the region to move, inclusive.
TO       --- The right point of the region to move, exclusive.
ADJUST   --- Whether to adjust the fill pointer and the array bounds. The array is only
             adjusted if N is positive and the range of TO+N would exceed the ARRAY length,
             or if N is negative and TO equals the length of the ARRAY
FILL     --- If provided, empty spaces created by the move will be filled with this element.
CONTENTS --- If provided, uses the contents to fill the new space. If |N| is greater than the
             length of this sequence, FILL is used to fill the rest of the space if it is
             provided. If not, an error is signalled. No matter whether N is negative or
             positive, the content is filled in from left to right in the order it is given.</pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:ENSURE-ARRAY-SIZE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3AENSURE-ARRAY-SIZE">ENSURE-ARRAY-SIZE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ARRAY</li>    <li class="argument">NEW-SPACE</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L23">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:NSLICE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3ANSLICE">NSLICE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">VECTOR</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">START</li>    <li class="argument">END</li>    <li class="argument">STEP</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L362">Source</a>  </header> <div class="docstring"><pre>Modifies the vector to a sub-vector of itself.

START --- If positive:
            the inclusive starting index of the slice
          If negative:
            the inclusive starting index of the slice from
            the end of the vector
          If NULL: same as zero
END   --- If positive:
            the exclusive ending index of the slice
          If negative:
            the exclusive ending index of the slice from
            the end of the vector.
          If NULL: same as the length of the vector
STEP  --- If above zero:
            the step size between elements of the slice
          If NULL: same as one

Note that this always modifies the passed vector, and
adjusts the fill pointer, if one is present.

See <a href="#FUNCTION%20ARRAY-UTILS%3ANSLICE" class="xref">NSLICE</a>
See <a href="#FUNCTION%20ARRAY-UTILS%3ASLICE%2A" class="xref">SLICE*</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:SLICE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3ASLICE">SLICE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">VECTOR</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">START</li>    <li class="argument">END</li>    <li class="argument">STEP</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L269">Source</a>  </header> <div class="docstring"><pre>Creates a sub-vector of the given vector.

START --- If positive:
            the inclusive starting index of the slice
          If negative:
            the inclusive starting index of the slice from
            the end of the vector
          If NULL: same as zero
END   --- If positive:
            the exclusive ending index of the slice
          If negative:
            the exclusive ending index of the slice from
            the end of the vector.
          If NULL: same as the length of the vector
STEP  --- If above zero:
            the step size between elements of the slice
          If NULL: same as one

Note that this always creates a fresh copy of the vector,
preserving the element type and other properties.

See <a href="#FUNCTION%20ARRAY-UTILS%3ANSLICE" class="xref">NSLICE</a>
See <a href="#FUNCTION%20ARRAY-UTILS%3ASLICE%2A" class="xref">SLICE*</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:SLICE*"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3ASLICE%2A">SLICE*</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">VECTOR</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">START</li>    <li class="argument">END</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L323">Source</a>  </header> <div class="docstring"><pre>Creates a sub-vector of the given vector.

START --- If positive:
            the inclusive starting index of the slice
          If negative:
            the inclusive starting index of the slice from
            the end of the vector
          If NULL: same as zero
END   --- If positive:
            the exclusive ending index of the slice
          If negative:
            the exclusive ending index of the slice from
            the end of the vector.
          If NULL: same as the length of the vector

Note that this creates a displaced vector pointing to the
original vector. It thus shares the data with the original
vector, and does not support a STEP size other than 1.

See <a href="#FUNCTION%20ARRAY-UTILS%3ASLICE" class="xref">SLICE</a>
See <a href="#FUNCTION%20ARRAY-UTILS%3ANSLICE" class="xref">NSLICE</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:VECTOR-APPEND"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-APPEND">VECTOR-APPEND</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">VECTOR</li>    <li class="argument">SEQUENCE</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">POSITION</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L241">Source</a>  </header> <div class="docstring"><pre>Appends all elements of the sequence at position of the vector and returns it.
This is potentially very costly as all elements after the given position
need to be shifted back as per ARRAY-SHIFT.</pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:VECTOR-POP-ELEMENT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-ELEMENT">VECTOR-POP-ELEMENT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">VECTOR</li>    <li class="argument">ELEMENT</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L213">Source</a>  </header> <div class="docstring"><pre>Pops the element from the vector and returns it if it was contained.
This is potentially very costly as all elements after the given position
need to be shifted back as per ARRAY-SHIFT.

If the array has an element-type of T, the element moved beyond the fill
pointer is set to NIL to avoid a memory leak.

See <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-POSITION" class="xref">VECTOR-POP-POSITION</a>
See <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-ELEMENT%2A" class="xref">VECTOR-POP-ELEMENT*</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:VECTOR-POP-ELEMENT*"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-ELEMENT%2A">VECTOR-POP-ELEMENT*</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">VECTOR</li>    <li class="argument">ELEMENT</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L227">Source</a>  </header> <div class="docstring"><pre>Pops the element from the vector and returns it if it was contained.
This is faster than VECTOR-POP-ELEMENT, but does not preserve the order of elements
in the vector.

If the array has an element-type of T, the element moved beyond the fill
pointer is set to NIL to avoid a memory leak.

See <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-POSITION%2A" class="xref">VECTOR-POP-POSITION*</a>
See <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-ELEMENT" class="xref">VECTOR-POP-ELEMENT</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:VECTOR-POP-FRONT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-FRONT">VECTOR-POP-FRONT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">VECTOR</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L195">Source</a>  </header> <div class="docstring"><pre>Pops the first element off the vector and returns it.
This operation is very costly and takes O(n) time as each element needs to
be shifted as per ARRAY-SHIFT.

See <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-FRONT%2A" class="xref">VECTOR-POP-FRONT*</a>
See <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-POSITION" class="xref">VECTOR-POP-POSITION</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:VECTOR-POP-FRONT*"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-FRONT%2A">VECTOR-POP-FRONT*</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">VECTOR</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L204">Source</a>  </header> <div class="docstring"><pre>Pops the first element off the vector and returns it.
This is faster than VECTOR-POP-FRONT, but does not preserve the order of elements
in the vector.

See <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-FRONT" class="xref">VECTOR-POP-FRONT</a>
See <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-POSITION" class="xref">VECTOR-POP-POSITION</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:VECTOR-POP-POSITION"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-POSITION">VECTOR-POP-POSITION</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">VECTOR</li>    <li class="argument">POSITION</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L161">Source</a>  </header> <div class="docstring"><pre>Pops the element at the given position of the vector and returns it.
This is potentially very costly as all elements after the given position
need to be shifted back as per ARRAY-SHIFT.

If the array has an element-type of T, the element moved beyond the fill
pointer is set to NIL to avoid a memory leak.

See <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-POSITION%2A" class="xref">VECTOR-POP-POSITION*</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:VECTOR-POP-POSITION*"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-POSITION%2A">VECTOR-POP-POSITION*</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">VECTOR</li>    <li class="argument">POSITION</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L181">Source</a>  </header> <div class="docstring"><pre>Pops the element at the given position of the vector and returns it.
This is faster than VECTOR-POP-POSITION, but does not preserve the order of elements
in the vector.

If the array has an element-type of T, the element moved beyond the fill
pointer is set to NIL to avoid a memory leak.

See <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-POP-POSITION" class="xref">VECTOR-POP-POSITION</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:VECTOR-PUSH-EXTEND-FRONT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-PUSH-EXTEND-FRONT">VECTOR-PUSH-EXTEND-FRONT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ELEMENT</li>    <li class="argument">VECTOR</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L124">Source</a>  </header> <div class="docstring"><pre>Pushes the element onto the front of the vector and extends if necessary.
This operation is very costly and takes O(n) time as each element needs to
be shifted as per ARRAY-SHIFT.

See <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-PUSH-EXTEND-POSITION" class="xref">VECTOR-PUSH-EXTEND-POSITION</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:VECTOR-PUSH-EXTEND-NEW"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-PUSH-EXTEND-NEW">VECTOR-PUSH-EXTEND-NEW</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ELEMENT</li>    <li class="argument">VECTOR</li>    <li class="argument lambda-list-keyword">&amp;KEY</li>    <li class="argument">KEY</li>    <li class="argument">TEST</li>    <li class="argument">TEST-NOT</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L132">Source</a>  </header> <div class="docstring"><pre>Pushes the element onto the back of the vector and extends if necessary, if it is not already part of the vector.

If TEST is passed, it is used to compare the elements. Defaults to EQL
If TEST-NOT is passed, its complement is used to compare the element.
If KEY is passed, it is used to extract the element comparison key for
both ELEMENT and each element in VECTOR.

Returns the existing element in VECTOR or the new ELEMENT if it was
inserted at the end.

See <a href="http://l1sp.org/cl/vector-push-extend" class="xref">CL:VECTOR-PUSH-EXTEND</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION ARRAY-UTILS:VECTOR-PUSH-EXTEND-POSITION"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20ARRAY-UTILS%3AVECTOR-PUSH-EXTEND-POSITION">VECTOR-PUSH-EXTEND-POSITION</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ELEMENT</li>    <li class="argument">VECTOR</li>    <li class="argument">POSITION</li>  </ul>  <a class="source-link" href="https://shinmera.com/project/array-utils/blob/e71aaf14be270d4aa1e5ba6fa9319e2de776dda0/utils.lisp#L116">Source</a>  </header> <div class="docstring"><pre>Pushes the element into the specified position and shifts everything
to the right to make space. This is potentially very costly as all
elements after the given position need to be shifted as per ARRAY-SHIFT.</pre></div> </article> </li> </ul> </article> </li> </ul> </section>  </article> <script>window.addEventListener("DOMContentLoaded", function(){
    var unmarkElement = function(el){
        if(el.tagName === "mark" || el.tagName === "MARK"){
            [].forEach.call(el.childNodes, function(child){
                el.parentNode.insertBefore(child, el);
            });
            el.parentNode.removeChild(el);
        }else if(el.parentNode.tagName === "mark"){
            return unmarkElement(el.parentNode);
        }
        return null;
    }

    var unmarkAll = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("mark"), unmarkElement);
    }
    
    var markElement = function(el){
        if(el.parentNode.tagName === "mark" || el.parentNode.tagName === "MARK"){
            return el.parentNode;
        } else {
            unmarkAll();
            var marked = document.createElement("mark");
            el.parentNode.insertBefore(marked, el);
            marked.appendChild(el);
            return marked;
        }
    }

    var markFragmented = function(){
        if(window.location.hash){
            var el = document.getElementById(decodeURIComponent(window.location.hash.substr(1)));
            if(el) markElement(el);
        }
    }

    var registerXrefLink = function(link){
        var el = document.getElementById(decodeURIComponent(link.getAttribute("href").substr(1)));
        if(el){
            link.addEventListener("click", function(){
                markElement(el);
            });
        }
    }

    var registerXrefLinks = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("a.xref"), registerXrefLink);
    }

    markFragmented();
    registerXrefLinks();
}); </script> </body> </html> 
